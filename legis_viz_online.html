<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Legislation Visualizations - online</title>
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script defer src="/assets/js/language.js"></script>
<style>
body{margin:0;background:#0b0e11;color:#e5e7eb;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
.left{position:fixed;left:0;top:0;bottom:0;width:340px;background:#141a1f;border-right:1px solid #111827;padding:14px;overflow:auto}
.right{margin-left:340px;padding:12px}
h1{font-size:18px;margin:0 0 12px 0}
.card{background:#141a1f;border:1px solid #111827;border-radius:12px;padding:12px;margin-bottom:12px}
input[type=file]{width:100%;padding:8px;border:1px solid #334155;border-radius:10px;background:#0b1220;color:#e5e7eb}
.small{color:#9ca3af;font-size:12px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
#grid,#net3d{height:calc(100vh - 100px);background:#141a1f;border-radius:12px}
.tab{padding:8px 12px;background:#1f2937;border:1px solid #111827;border-radius:10px;cursor:pointer}
.tab.on{background:#3b82f6}
.chip{padding:6px 10px;border-radius:999px;background:#1f2937;border:1px solid #111827;cursor:pointer}
.chip.on{background:#2563eb}
.counter{margin-left:6px;background:#0b1220;padding:2px 6px;border-radius:8px;color:#9ca3af;font-size:12px}
.bad{color:#fca5a5}
.good{color:#86efac}
.language-switcher{display:flex;justify-content:flex-start;gap:8px;margin-bottom:12px}
.language-switcher__btn{appearance:none;border:1px solid #1f2937;background:#0f172a;color:#f8fafc;padding:6px 14px;border-radius:999px;font-size:12px;cursor:pointer;transition:background .2s ease,border-color .2s ease}
.language-switcher__btn:hover{background:#1d4ed8;border-color:#1d4ed8}
.language-switcher__btn.is-active{background:#2563eb;border-color:#2563eb}
</style>
</head>
<body>
<div class="left">
  <div class="language-switcher" role="navigation" aria-label="Language selector">
    <button type="button" class="language-switcher__btn" data-language-toggle="en" aria-pressed="false">English</button>
    <button type="button" class="language-switcher__btn" data-language-toggle="it" aria-pressed="false">Italiano</button>
  </div>
  <h1 id="page-title">CSV viewer</h1>
  <div class="card">
    <div class="small" id="intro-text">This page auto-loads <code>legislation_for_viewer_safe.csv</code> from the same folder. Or choose a local CSV.</div>
    <input id="file" type="file" accept=".csv" />
    <div id="status" class="small"></div>
  </div>
  <div class="card">
    <div class="small" id="filters-label">Filters</div>
    <div class="small" id="level-label">Level</div><div id="level" class="row"></div>
    <div class="small" id="technology-label">Technology</div><div id="tech" class="row"></div>
  </div>
  <div class="card">
    <div class="small" id="errors-label">Errors</div>
    <div id="errors" class="small"></div>
  </div>
</div>
<div class="right">
  <div class="row"><button id="tab1" class="tab on">2D grid</button><button id="tab2" class="tab">3D network</button></div>
  <div id="grid"></div>
  <div id="net3d" style="display:none"></div>
</div>

<script>
(function () {
  const COPY = {
    en: {
      pageTitle: 'Legislation Visualizations - online',
      header: 'CSV viewer',
      introHtml: 'This page auto-loads <code>legislation_for_viewer_safe.csv</code> from the same folder. Or choose a local CSV.',
      filters: 'Filters',
      level: 'Level',
      technology: 'Technology',
      errors: 'Errors',
      tabGrid: '2D grid',
      tabNetwork: '3D network',
      statusLoadingRemote: 'Loading remote CSV...',
      statusRemoteMissing: 'Remote CSV not found. Choose a file instead.',
      statusParsing: 'Parsing CSV...',
      statusLoaded: (rows, cols) => 'Loaded ' + rows + ' rows - Columns: ' + cols.join(', '),
      statusMissingColumns: (cols) => 'Missing required columns. Present: ' + cols.join(', '),
      statusParsingError: (message) => message,
      annotationNoRows: 'No rows to display'
    },
    it: {
      pageTitle: 'Visualizzazioni normative - online',
      header: 'Visualizzatore CSV',
      introHtml: 'Questa pagina carica automaticamente <code>legislation_for_viewer_safe.csv</code> dalla stessa cartella. Oppure scegli un CSV locale.',
      filters: 'Filtri',
      level: 'Livello',
      technology: 'Tecnologia',
      errors: 'Errori',
      tabGrid: 'Griglia 2D',
      tabNetwork: 'Rete 3D',
      statusLoadingRemote: 'Caricamento del CSV remoto...',
      statusRemoteMissing: 'CSV remoto non trovato. Seleziona un file locale.',
      statusParsing: 'Analisi del CSV in corso...',
      statusLoaded: (rows, cols) => 'Caricate ' + rows + ' righe - Colonne: ' + cols.join(', '),
      statusMissingColumns: (cols) => 'Mancano colonne obbligatorie. Presenti: ' + cols.join(', '),
      statusParsingError: (message) => message,
      annotationNoRows: 'Nessuna riga da visualizzare'
    }
  };

  const state = {
    lang: 'en',
    copy: COPY.en,
    status: { key: 'loadingRemote', context: {}, variant: 'neutral' }
  };

  const by = (id) => document.getElementById(id);
  const statusEl = by('status');

  const split = (s) => String(s || '').split(/[;|,/]/).map((x) => x.trim()).filter(Boolean);
  const uniq = (array) => Array.from(new Set(array));
  const truthy = (value) => value !== undefined && value !== null && String(value).trim() !== '';

  let FULL = [];
  let EDGES = [];

  const opts = {
    categoryOrder: ['Strategy', 'Regulation', 'Instruments'],
    pillarOrder: ['Sustainability', 'Sovereignty', 'Values', 'Competitiveness']
  };

  function renderStatus() {
    const { key, context, variant } = state.status;
    let message = '';
    if (key === 'loadingRemote') {
      message = state.copy.statusLoadingRemote;
    } else if (key === 'remoteMissing') {
      message = state.copy.statusRemoteMissing;
    } else if (key === 'parsing') {
      message = state.copy.statusParsing;
    } else if (key === 'loaded') {
      const rows = Number(context.rows || 0);
      const cols = Array.isArray(context.columns) ? context.columns : [];
      message = state.copy.statusLoaded(rows, cols);
    } else if (key === 'missingColumns') {
      const cols = Array.isArray(context.columns) ? context.columns : [];
      message = state.copy.statusMissingColumns(cols);
    } else if (key === 'parsingError') {
      message = state.copy.statusParsingError(String(context.message || ''));
    }

    if (variant === 'good') {
      statusEl.innerHTML = '<span class="good">' + message + '</span>';
    } else if (variant === 'bad') {
      statusEl.innerHTML = '<span class="bad">' + message + '</span>';
    } else {
      statusEl.textContent = message;
    }
  }

  function setStatus(key, context, variant) {
    state.status = {
      key: key || 'loadingRemote',
      context: context || {},
      variant: variant || 'neutral'
    };
    renderStatus();
  }

  function applyCopy(lang) {
    const nextLang = COPY[lang] ? lang : 'en';
    state.lang = nextLang;
    state.copy = COPY[nextLang];

    document.title = state.copy.pageTitle;
    by('page-title').textContent = state.copy.header;
    by('intro-text').innerHTML = state.copy.introHtml;
    by('filters-label').textContent = state.copy.filters;
    by('level-label').textContent = state.copy.level;
    by('technology-label').textContent = state.copy.technology;
    by('errors-label').textContent = state.copy.errors;
    by('tab1').textContent = state.copy.tabGrid;
    by('tab2').textContent = state.copy.tabNetwork;

    renderStatus();
  }

  function makeChips(values, mountId, onChange) {
    const mount = by(mountId);
    mount.innerHTML = '';
    values.forEach((value) => {
      const el = document.createElement('span');
      el.className = 'chip on';
      el.textContent = value.label;
      const counter = document.createElement('span');
      counter.className = 'counter';
      counter.textContent = value.count;
      el.appendChild(counter);
      el.onclick = () => {
        el.classList.toggle('on');
        onChange();
      };
      value._el = el;
      mount.appendChild(el);
    });
    return values;
  }

  function buildEdges(rows) {
    const result = [];
    const seen = new Set();
    rows.forEach((row) => {
      if (row.source && row.target) {
        const key = row.source + '::' + row.target;
        if (!seen.has(key)) {
          result.push({ s: row.source, t: row.target });
          seen.add(key);
        }
      }
      if (row.name && row.relates_to) {
        row.relates_to.forEach((target) => {
          const key = row.name + '::' + target;
          if (!seen.has(key)) {
            result.push({ s: row.name, t: target });
            seen.add(key);
          }
        });
      }
      if (row.parent) {
        const key = row.parent + '::' + row.name;
        if (!seen.has(key)) {
          result.push({ s: row.parent, t: row.name });
          seen.add(key);
        }
      }
    });
    return result;
  }

  function gridPlot(rows, edges) {
    const el = by('grid');
    if (!rows.length) {
      Plotly.react(
        el,
        [],
        {
          annotations: [
            {
              text: state.copy.annotationNoRows,
              xref: 'paper',
              yref: 'paper',
              x: 0.5,
              y: 0.5,
              showarrow: false,
              font: { size: 16, color: '#9ca3af' }
            }
          ],
          paper_bgcolor: 'rgba(0,0,0,0)',
          plot_bgcolor: 'rgba(0,0,0,0)'
        }
      );
      return;
    }
    const pillars = uniq(rows.map((row) => row.pillar)).sort(
      (a, b) => opts.pillarOrder.indexOf(a) - opts.pillarOrder.indexOf(b)
    );
    const categories = uniq(rows.map((row) => row.category)).sort(
      (a, b) => opts.categoryOrder.indexOf(a) - opts.categoryOrder.indexOf(b)
    );
    const pillarIndex = Object.fromEntries(pillars.map((pillar, idx) => [pillar, idx]));
    const categoryIndex = Object.fromEntries(categories.map((category, idx) => [category, idx]));
    const cells = {};
    const items = rows.map((row) => {
      const pIdx = pillarIndex[row.pillar] || 0;
      const cIdx = categoryIndex[row.category] || 0;
      const key = pIdx + '|' + cIdx;
      cells[key] = (cells[key] || 0) + 1;
      const count = cells[key];
      const x = pIdx + ((count - 1) / Math.max(1, count) - 0.5) * 0.8;
      return { ...row, x: x, y: cIdx };
    });
    const coordinates = Object.fromEntries(items.map((item) => [item.name, [item.x, item.y]]));
    const edgeTraces = [];
    edges.forEach((edge) => {
      if (!coordinates[edge.s] || !coordinates[edge.t]) {
        return;
      }
      const [x0, y0] = coordinates[edge.s];
      const [x1, y1] = coordinates[edge.t];
      edgeTraces.push({
        type: 'scatter',
        mode: 'lines',
        x: [x0, x1],
        y: [y0, y1],
        line: { width: 1, color: '#6b7280' },
        hoverinfo: 'skip',
        showlegend: false
      });
    });
    const nodeTrace = {
      type: 'scatter',
      mode: 'markers+text',
      x: items.map((item) => item.x),
      y: items.map((item) => item.y),
      text: items.map((item) => item.name),
      marker: {
        size: 14,
        color: '#3b82f6',
        line: { width: 1, color: '#1e293b' }
      },
      textposition: 'top center',
      textfont: { color: '#e5e7eb', size: 10 },
      hovertemplate: '%{text}<extra></extra>'
    };
    Plotly.react(
      el,
      [...edgeTraces, nodeTrace],
      {
        xaxis: {
          tickvals: pillars.map((_, idx) => idx),
          ticktext: pillars,
          color: '#9ca3af',
          gridcolor: '#1f2937',
          zeroline: false
        },
        yaxis: {
          tickvals: categories.map((_, idx) => idx),
          ticktext: categories,
          color: '#9ca3af',
          gridcolor: '#1f2937',
          zeroline: false
        },
        margin: { l: 40, r: 20, t: 20, b: 40 },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)'
      },
      { displaylogo: false, responsive: true }
    );
  }

  function net3D(rows, edges) {
    const el = by('net3d');
    if (!rows.length) {
      Plotly.react(el, [], { paper_bgcolor: 'rgba(0,0,0,0)' });
      return;
    }
    const nodes = rows.map((row, idx) => ({
      id: row.name,
      idx: idx,
      pillar: row.pillar,
      category: row.category
    }));
    const nodeIndex = Object.fromEntries(nodes.map((node, idx) => [node.id, idx]));
    const edgePairs = edges
      .map((edge) => [nodeIndex[edge.s], nodeIndex[edge.t]])
      .filter(([from, to]) => from !== undefined && to !== undefined);
    const coords = nodes.map((node) => ({
      x: opts.pillarOrder.indexOf(node.pillar) * 2,
      y: opts.categoryOrder.indexOf(node.category) * 2,
      z: node.idx * 0.3
    }));
    const edgeTrace = {
      type: 'scatter3d',
      mode: 'lines',
      x: edgePairs.flatMap(([from]) => [coords[from].x, coords[from].x, null]),
      y: edgePairs.flatMap(([from, to]) => [coords[from].y, coords[to].y, null]),
      z: edgePairs.flatMap(([from, to]) => [coords[from].z, coords[to].z, null]),
      line: { color: '#64748b', width: 2 },
      hoverinfo: 'none'
    };
    const nodeTrace = {
      type: 'scatter3d',
      mode: 'markers+text',
      x: coords.map((coord) => coord.x),
      y: coords.map((coord) => coord.y),
      z: coords.map((coord) => coord.z),
      text: nodes.map((node) => node.id),
      marker: { size: 5, color: '#3b82f6' },
      textfont: { color: '#e5e7eb', size: 9 },
      hovertemplate: '%{text}<extra></extra>'
    };
    Plotly.react(
      el,
      [edgeTrace, nodeTrace],
      {
        scene: {
          xaxis: { color: '#9ca3af', backgroundcolor: 'rgba(0,0,0,0)', gridcolor: '#1f2937' },
          yaxis: { color: '#9ca3af', backgroundcolor: 'rgba(0,0,0,0)', gridcolor: '#1f2937' },
          zaxis: { color: '#9ca3af', backgroundcolor: 'rgba(0,0,0,0)', gridcolor: '#1f2937' },
          camera: { eye: { x: 1.6, y: 1.4, z: 0.9 } }
        },
        paper_bgcolor: 'rgba(0,0,0,0)',
        margin: { l: 0, r: 0, t: 0, b: 0 }
      },
      { displaylogo: false, responsive: true }
    );
  }

  function applyFilters(levelChips, techChips) {
    const activeLevels = levelChips.filter((chip) => chip._el.classList.contains('on')).map((chip) => chip.label);
    const activeTech = techChips.filter((chip) => chip._el.classList.contains('on')).map((chip) => chip.label);
    const rows = FULL.filter(
      (row) =>
        (activeLevels.length ? activeLevels.includes(row.level) : true) &&
        (activeTech.length ? row.technology.some((tech) => activeTech.includes(tech)) : true)
    );
    const edges = EDGES.filter(
      (edge) => rows.some((row) => row.name === edge.s) && rows.some((row) => row.name === edge.t)
    );
    gridPlot(rows, edges);
    net3D(rows, edges);
  }

  function display(rowsRaw) {
    const columns = Object.keys(rowsRaw[0] || {});
    const lower = Object.fromEntries(columns.map((col) => [col.toLowerCase(), col]));
    const pick = (choices) => {
      for (const choice of choices) {
        if (lower[choice]) {
          return lower[choice];
        }
      }
      return '';
    };
    const nameCol = pick(['name', 'title', 'acronym', 'label']);
    const categoryCol = pick(['category', 'type']);
    const pillarCol = pick(['pillar', 'domain', 'theme']);
    if (!nameCol || !categoryCol || !pillarCol) {
      setStatus('missingColumns', { columns: columns }, 'bad');
      return;
    }
    const levelCol = pick(['level', 'jurisdiction']);
    const techCol = pick(['technology', 'tags', 'tech', 'topic']);
    const sourceCol = pick(['source', 'from', 'src']);
    const targetCol = pick(['target', 'to', 'dst']);
    const relatesCol = pick(['relates_to', 'links', 'related', 'relations']);
    const parentCol = pick(['parent', 'parent_id']);

    FULL = rowsRaw
      .map((row) => ({
        name: String(row[nameCol] || '').trim(),
        category: String(row[categoryCol] || '').trim(),
        pillar: String(row[pillarCol] || '').trim(),
        level: levelCol ? String(row[levelCol] || 'All').trim() : 'All',
        technology: techCol ? split(row[techCol]) : [],
        source: sourceCol ? String(row[sourceCol] || '').trim() : '',
        target: targetCol ? String(row[targetCol] || '').trim() : '',
        relates_to: relatesCol ? split(row[relatesCol]) : [],
        parent: parentCol ? String(row[parentCol] || '').trim() : ''
      }))
      .filter((row) => truthy(row.name) && truthy(row.category) && truthy(row.pillar));

    EDGES = buildEdges(FULL);
    const levels = uniq(FULL.map((row) => row.level));
    const techs = uniq(FULL.flatMap((row) => row.technology));

    const levelChips = makeChips(
      levels.map((level) => ({
        label: level,
        count: FULL.filter((row) => row.level === level).length
      })),
      'level',
      () => applyFilters(levelChips, techChips)
    );
    const techChips = makeChips(
      techs.map((tech) => ({
        label: tech,
        count: FULL.filter((row) => row.technology.includes(tech)).length
      })),
      'tech',
      () => applyFilters(levelChips, techChips)
    );

    setStatus('loaded', { rows: FULL.length, columns: columns }, 'good');
    applyFilters(levelChips, techChips);
  }

  async function tryFetchDefault() {
    try {
      const response = await fetch('legislation_for_viewer_safe.csv', { cache: 'no-store' });
      if (!response.ok) {
        throw new Error('HTTP ' + response.status);
      }
      const text = await response.text();
      const parsed = Papa.parse(text, { header: true, skipEmptyLines: true, dynamicTyping: false });
      if (parsed.errors && parsed.errors.length) {
        console.warn(parsed.errors.slice(0, 3));
      }
      display(parsed.data);
    } catch (error) {
      setStatus('remoteMissing', {}, 'bad');
    }
  }

  by('tab1').onclick = () => {
    by('tab1').classList.add('on');
    by('tab2').classList.remove('on');
    by('grid').style.display = 'block';
    by('net3d').style.display = 'none';
  };
  by('tab2').onclick = () => {
    by('tab2').classList.add('on');
    by('tab1').classList.remove('on');
    by('grid').style.display = 'none';
    by('net3d').style.display = 'block';
  };

  by('file').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) {
      return;
    }
    setStatus('parsing');
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      dynamicTyping: false,
      complete: (result) => display(result.data),
      error: (err) => setStatus('parsingError', { message: err.message }, 'bad')
    });
  });

  window.addEventListener('site:language-change', (event) => {
    applyCopy(event.detail.language);
  });

  setStatus('loadingRemote');
  applyCopy(window.__siteLanguage || 'en');
  tryFetchDefault();
})();
</script>
</body>
</html>
